// Generated by Qodo Gen

import { HybridWebCache, StorageType } from '../src';
import { Utils } from '../src/core/utils/Utils';

interface IPerson {
  name: string;
  age: number;
}

const persons: IPerson[] = [
  { name: 'John Doe', age: 30 },
  { name: 'Jane Doe', age: 33 },
];

describe('HybridWebCache', () => {
  const hwc = new HybridWebCache();
  const hwcSync = new HybridWebCache('syncCache');

  // Constructor initializes with default options when no options provided
  it('should initialize with default options when constructed without parameters', () => {
    const cache = new HybridWebCache();

    expect(cache.info).toEqual(
      {
        dataBase: 'HybridWebCache',
        size: '0b',
        options: {
          ttl: 1 * 60 * 60 * 1000,
          removeExpired: true,
          storage: StorageType.LocalStorage
        }
      }
    );
  });

  it('test info size', () => {
    const cache = new HybridWebCache();

    expect(cache.lenght).toBe(0);
    expect(cache.bytes).toBe(0);

    cache.setSync('persons', persons);
    expect(cache.lenght).toBe(1);
    expect(cache.bytes).toBeGreaterThanOrEqual(100);
    expect(cache.info.size).toBeDefined();

    cache.unsetSync('persons');
    expect(cache.getJsonSync()).toBeNull();
  });

  // Set/get operations work with basic key-value pairs
  it('should set and get basic key-value pairs correctly', async () => {
    const cache = new HybridWebCache();
    const testKey = 'testKey';
    const testValue = 'testValue';

    await cache.set(testKey, testValue);
    const result = await cache.get(testKey);

    expect(result?.value).toBe(testValue);
    expect(result?.isExpired).toBe(false);

    await cache.unset(testKey);
    expect((await cache.getJson())).toBeNull();
  });

  // Handle expired items during get operations with removeExpired flag
  it('should remove expired items when removeExpired flag is true', async () => {
    const cache = new HybridWebCache('test', {
      ttl: { seconds: 1 }, removeExpired: false, storage: StorageType.Memory
    });

    await cache.set('key', 'value');
    expect(cache.bytes).toBeGreaterThanOrEqual(50);
    
    await new Promise(resolve => setTimeout(resolve, 1100));
    
    const notRemove = await cache.get('key');
    expect(notRemove?.isExpired).toBeTruthy();
    expect(notRemove?.value).toBe('value');

    const remove = await cache.get('key', true);
    expect(remove).toBeUndefined();
    
    const hasKey = await cache.has('key');
    expect(hasKey).toBeFalsy();
    
    await cache.setSync('key1', 'value');
    cache.setSync('key2', 'value');
    cache.unsetSync();
    expect(cache.getAllSync()).toBeNull();
    expect(cache.lenght).toBe(0);
    expect(cache.bytes).toBe(0);
  });

  // Handle nested object paths in key operations
  it('should handle nested object paths correctly', async () => {
    const cache = new HybridWebCache();
    const nestedPath = 'user.profile.name';
    const value = 'John Doe';

    await cache.set(nestedPath, value);

    const result = await cache.get(nestedPath);
    expect(result?.value).toBe(value);

    const allData = await cache.getJson();
    expect(allData?.user?.profile?.name).toBe(value);
  });

  // // Storage engine automatically falls back based on availability (localStorage -> IndexedDB -> Memory)
  // it('should fall back to IndexedDB when localStorage is unavailable', () => {
  //   jest.spyOn(Utils, 'isLocalStorageAvailable').mockReturnValue(false);
  //   jest.spyOn(Utils, 'isIndexedDBAvailable').mockReturnValue(true);

  //   const cache = new HybridWebCache();

  //   expect(cache.storageType).toBe(StorageType.IndexedDB);
  // });

  // TTL expiration works correctly for cached items
  it('should remove expired items when TTL is exceeded', async () => {
    const cache = new HybridWebCache('testCache', { ttl: { seconds: 1 } });
    const key = 'testKey';
    const value = 'testValue';

    await cache.set(key, value);

    // Wait for TTL to expire
    await new Promise(resolve => setTimeout(resolve, 1500));

    const result = await cache.get(key);
    expect(result).toBeUndefined();
  });

  // GetAll retrieves all valid cached items
  it('should retrieve all valid cached items when getAll is called', async () => {
    const cache = new HybridWebCache('TestCache');

    await cache.set('key1', 'value1', 1000);
    await cache.set('key1', 'value2', 2000);

    // Wait for TTL to expire first
    await new Promise(resolve => setTimeout(resolve, 1500));

    const result = await cache.getAll();

    expect(result).toEqual(new Map([
      ['key1', { value: 'value2', expiresAt: expect.any(Number), isExpired: false }]
    ]));

    
    expect(cache.getSync('key1.value3')).toBeUndefined();
  });

  // JSON export/import functionality works as expected
  it('should correctly export and import JSON data', async () => {
    const cache = new HybridWebCache('TestCache', { storage: StorageType.Memory });
    const testData = { key1: 'value1', key2: 'value2' };

    await cache.resetWith(testData);

    const exportedJson = await cache.getJson();
    expect(exportedJson).toEqual(testData);

    const newCache = new HybridWebCache('TestCache', { storage: StorageType.Memory });
    await newCache.resetWith(exportedJson!);

    const importedJson = await newCache.getJson();
    expect(importedJson).toEqual(testData);
  });

  // Handle undefined/null values in set/get operations
  it('should handle undefined and null values correctly in set and get operations', async () => {
    const cache = new HybridWebCache();
    const expiresValue = Date.now() + 1000;

    // Test setting null value
    await cache.set('nullKey', null, 2000);
    let result = await cache.get('nullKey', false);

    expect(result?.value).toBeNull();
    expect(result?.expiresAt).toBeGreaterThanOrEqual(expiresValue);
    expect(result?.isExpired).toBe(false);

    // Test getting a non-existent key
    result = await cache.get('nonExistentKey');
    expect(result).toBeUndefined();

    await cache.set('customer.firstName', 'Heliomar');
    await cache.set('customer.lastName', 'Marques', { hours: 1 });
    expect((await cache.get('customer.middleName'))).toBeUndefined();

  });

  // Storage engine unavailability triggers appropriate fallbacks
  it('should fallback to Memory storage when both LocalStorage and IndexedDB are unavailable', () => {
    jest.spyOn(Utils, 'isLocalStorageAvailable').mockReturnValue(false);
    jest.spyOn(Utils, 'isIndexedDBAvailable').mockReturnValue(false);
    const cache = new HybridWebCache('TestCache', { storage: StorageType.Auto });

    expect(cache.storageType).toBe(StorageType.Memory);
  });

  // Empty or invalid keyPaths are handled gracefully
  it('should return undefined for empty or invalid keyPaths', async () => {
    const cache = new HybridWebCache();

    const resultForInvalidKeyPath = await cache.get(''); // Invalid keyPath
    const resultForEmptyKeyPath = await cache.get([]); // Empty keyPath

    expect(resultForInvalidKeyPath).toBeUndefined();
    expect(resultForEmptyKeyPath).toBeUndefined();
  });

  it('test set/get property of types', async () => {
    const cache = new HybridWebCache();

    // string value
    await cache.set('str', 'strValue');
    expect((await cache.get('str'))!.value).toBe('strValue');

    cache.setSync('strSync', 'strValueSync');
    expect(cache.getSync('strSync')!.value).toBe('strValueSync');

    // number value
    await cache.set('num', 1);
    expect((await cache.get('num'))!.value).toBe(1);

    cache.setSync('numSync', 2);
    expect(cache.getSync('numSync')!.value).toBe(2);

    // decimal value
    await cache.set('decSync', 2024.11);
    expect((await cache.get<number>('decSync'))!.value).toBeGreaterThanOrEqual(2024.11);

    cache.setSync('decSync', 2024.11);
    expect(cache.getSync<number>('decSync')!.value).toBeGreaterThanOrEqual(2024.11);

    // boolean value
    await cache.set('boolean', true);
    expect((await cache.get('boolean'))!.value).toBeTruthy();

    cache.setSync('booleanSync', false);
    expect(cache.getSync('booleanSync')!.value).toBeFalsy();

    // array value
    await cache.set('arr', ['testA', 'testB']);
    expect((await cache.get<object>('arr'))!.value).toMatchObject(['testA', 'testB']);

    cache.setSync('arrSync', ['testASync', 'testBSync', 'testCSync']);
    expect(cache.getSync<object>('arrSync')!.value).toMatchObject(['testASync', 'testBSync', 'testCSync']);

    // interface value
    const mapPerson = persons.map(person => ({ ...person }));
    await cache.set('persons', mapPerson);
    expect((await cache.get<IPerson[]>('persons'))!.value[0].name).toEqual('John Doe');
    expect((await cache.get<string>('persons[1].name'))!.value).toEqual('Jane Doe');
    expect(cache.getSync<Record<string, string>>('persons[1]')!.value['age']).toEqual(33);

    await cache.set('persons_index', [{ ...persons }]);
    expect(cache.getSync<IPerson[]>('persons_index')!.value).toStrictEqual([{ ...persons }]);

    // object value
    await cache.set('obj', { nome: 'Heliomar' });
    expect((await cache.get('obj.nome'))!.value).toBe('Heliomar');
    expect(cache.getSync('obj.nome')!.value).toBe('Heliomar');
    expect(cache.hasSync('obj.nome')).toBeTruthy();

    // increment in object type using ArrayProperties
    await cache.set(['obj', 'conjugue'], 'Angelina');
    expect((await cache.get('obj.conjugue'))!.value).toBe('Angelina');

    // increment in object type using NestedProperties (ttlMs/notRemoveExpired)'
    await cache.set('obj.sobreNome', 'Marques');
    expect((await cache.get('obj.sobreNome', false))!.value).toBe('Marques');

    //test get all property after added keys
    let result = await cache.get<object>('obj');
    
    expect(result).toMatchObject(
      {
        value: { nome: 'Heliomar', sobreNome: 'Marques', conjugue: 'Angelina' },
        expiresAt: expect.any(Number),
        isExpired: false
      }
    );

    await cache.unset('obj.sobreNome');
    expect(await cache.get('obj.sobreNome')).toBeUndefined();
    expect(await cache.has('obj.sobreNome')).toBeFalsy();

    result = await cache.get<object>('obj');
    
    expect(result).toMatchObject(
      {
        value: { nome: 'Heliomar', conjugue: 'Angelina' },
        expiresAt: expect.any(Number),
        isExpired: false
      }
    );

  });

  
  it('should deal with complex objects', async () => {
    const complex = {
      name: 'complex',
      type: 'object',
      properties: {
        height: 20,
        width: 30,
      },
    };

    const cache = new HybridWebCache();
    await cache.set('complex', complex);

    const result = await cache.get('complex');

    expect(result!.value).toMatchObject(complex);
    expect(typeof result!.value).toEqual(typeof complex);

    const value = cache.getSync<typeof complex>('complex')!.value;
    expect(value.properties.height).toBe(20);

    // get nested properties
    expect(cache.getSync('complex.name')!.value).toBe('complex');

    // get array properties
    expect(cache.getSync(['complex', 'properties', 'width'])!.value).toBe(30);

    cache.setSync(['complex', 'properties', 'type'], 'square');
    expect(cache.hasSync(['complex', 'properties', 'type'])).toBeTruthy();

    cache.setSync('complex.name', 'square');
    expect(cache.getSync('complex.name')!.value).toBe('square');

    cache.setSync(['complex', 'enabled'], true);
    cache.unsetSync('complex.type');
    cache.unsetSync('complex.properties');

    const all = cache.getAllSync();
    expect(all).toEqual(new Map([
      ['complex', { value: { name: 'square', enabled: true }, expiresAt: expect.any(Number), isExpired: false }]
    ]));

    const json = cache.getJsonSync();    
    expect(json).toEqual({
      complex: { name: 'square', enabled: true }
    });
  });

  it('test set/get on ttl expired and not remove expired', async () => {
    // set expired in .0001 = 1ms
    await hwc.set('user', { name: 'John Doe', age: 30 }, { seconds: 0.0001 });
    // force do not remove
    expect((await hwc.get<object>('user', false))!.value).toMatchObject({ age: 30, name: 'John Doe' });
  });
  it(
    'test get with remove expired',
    async () => {
      // remove expired cache
      expect((await hwc.get('user', true))).toBeUndefined();
    },
    1 * 1000,
  ); //1s
  it('test resetWith property', async () => {
    await hwc.resetWith({ propAsync: true });
    expect((await hwc.get('propAsync'))?.value).toBeTruthy();
  });
  it('test resetWithSync property', () => {
    hwc.resetWithSync({ testResetWith: 'OK', testSync: 'inRunner' });
    expect(hwc.getSync('testResetWith')!.value).toEqual('OK');
    expect(hwc.getSync('testSync')!.value).toEqual('inRunner');
  });
  it('test set/get property value null', async () => {
    await hwc.set('nullAsync', null);
    expect((await hwc.get('nullAsync'))!.value).toBeNull();
  });
  it('test setSync/getSync property value null', () => {
    hwc.setSync<null>('null', null);
    expect(hwc.getSync<null>('null')!.value).toBeNull();
  });


  it('should reset methods async', async () => {
    await hwc.resetWith({});
    await hwc.set('async', true);
    await hwc.set('unsetAsync', true);
    await hwc.set('objAsync.testing', true);
    await hwc.set('objAsync.willExpire', 'removeAsync', 1);
  });
  it('should all methods async', async () => {
    expect((await hwc.getAll(false))!.size).toBe(3); //not remove expired
    expect((await hwc.get('async'))!.value).toBeTruthy();
    expect(await hwc.get('objAsync.willExpire')).toBeUndefined();
    expect(await hwc.get('objAsync')).toBeUndefined();

    expect(await hwc.unset('unsetAsync')).toBeTruthy();
    expect(await hwc.get('unsetAsync')).toBeUndefined();
    expect(await hwc.getJson()).toEqual({ async: true });

    expect(await hwc.has('async')).toBeTruthy();
    expect(await hwc.unset()).toBeTruthy();
    expect(await hwc.getAll()).toBeNull();
  }, 1000);

  it('should set expired value (async)', async () => {    
    await hwc.setSync('asyncExpired', 1, 1);    
  });

  it('should get all after expired (async)', async () => {
    expect((await hwc.getAll(true))).toBeNull();
  }, 1000);


  it('should reset methods sync', async () => {
    hwcSync.resetWithSync({});
    hwcSync.setSync('sync', true);
    hwcSync.setSync('unsetSync', true);
    hwcSync.setSync('objSync.testing', true);
    hwcSync.setSync('objSync.willExpire', 'remove', 1);
  });
  it('should all methods sync', async () => {
    expect(hwcSync.getAllSync(false)!.size).toBe(3); //not remove expired
    expect(hwcSync.getSync('sync')!.value).toBeTruthy();
    expect(hwcSync.getSync('objSync.willExpire', true)).toBeUndefined();
    expect(hwcSync.getSync('objSync')).toBeUndefined();

    expect(hwcSync.unsetSync('unsetSync')).toBeTruthy();
    expect(hwcSync.getSync('unsetSync')).toBeUndefined();
    expect(hwcSync.getJsonSync()).toEqual({ sync: true });

    expect(hwcSync.hasSync('sync')).toBeTruthy();
    expect(hwcSync.unsetSync()).toBeTruthy();
    expect(hwcSync.getAllSync()).toBeNull();
  }, 1000);

  it('should set expired value (sync)', () => {
    hwc.setSync('syncExpired', 1, 1);    
  });

  it('should get all after expired (sync)', () => {
    expect((hwc.getAllSync(true))).toBeNull();
  }, 1000);

  it('should info with lorem ipsum', () => {
    const cache = new HybridWebCache('loremIpsum', { storage: StorageType.Memory });

    cache.setSync('loremIpsum', 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.');
    cache.setSync('loremIpsum1', 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.');
    cache.setSync('loremIpsum2', 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.');

    expect(cache.info).toEqual(
      {
        dataBase: 'loremIpsum',
        size: '1.49kb',
        options: {
          ttl: 1 * 60 * 60 * 1000,
          removeExpired: true,
          storage: StorageType.Memory
        }
      }
    );
  });

});
